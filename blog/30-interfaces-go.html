<!DOCTYPE html>
<html>

	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Joseph M. Sleiman -- A short study of interfaces in go</title>
		<link href="/css/style.css" rel="stylesheet" type="text/css">
		<!-- syntax higlighting -->
		<link rel="stylesheet" href="/css/github.css">
		<script src="/js/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>

	<body>
		<div class="frontpage">
			<a href="/about.html" class="floatleft navigation">About Me</a>
			<a href="" class="floatright navigation">fr</a>
			<br/>
			<a href="/" class="floatleft navigation">‚Üê Back to the front page</a>
			<br />

			<h1>A short study of interfaces in go</h1>
				<p>A while ago, I came across a short "tutorial" in go -- more of a study really. It covered a developer's struggle to better understand the applications of interfaces in go, and how they can be leveraged to create more modular and more readable code. I haven't been able to find the article, and figured I could probably re-write it... Hopefully you find some value in this little excercise. :)</p>
				<p>This article doesn't cover <code>interface{}</code>, and it assumes you already understand some go basics, and understand some principles of object-oriented design. Go is not strictly object-oriented, but is instead a more multi-paradigm language with strong biases. The go team tried to pluck concepts from all sorts of languages, to varying degrees of success.</p>
				<p>A little on me: I come from an academic Java background. I also learned a lot of Python and JavaScript while in school. I've also worked a little bit with C# at a previous job, and worked a bit with C and C++, and other languages, but only for fun on small projects. I started my career on Go, so my experience is going to be somewhat grounded in that for this article.</p>

				<h2>How Go does object-oriented</h2>
					<p>One thing that is interesting in go is how inheritance is similar to most languages in theory -- it's actually by composition -- but interfaces are somewhat different. Inheritance by composition allows us to access the inherited types as properties, and allows for multiple inheritance. The real magic for this article though is in how interfaces are applied:</p>
					<p>In short, interfaces are applied <i>after the fact</i>; you can define an interface, and any structs that meet that requirement implement the interface.</p>
					<p>This is really powerful when you think about it -- let it sit for a second. Unlike my experience in Java and C# -- where I need to explicitly state "this will implement these interfaces..." go lets us do it the other way around: "if it looks like this and quacks like this, it's an X".</p>
					<p>The standard library is littered with many good interface types already, and it's super easy to write your own. And when you do write your own, you can apply other peoples' structs to it -- so you can suddenly discover that all these structs from all these libraries share a few methods, and presto! They're now compatible.</p>
				<h2>Example </h2>
<pre><code class="go">
package main

import "fmt"

func main(){
	fmt.Println("hello world!")
}
</code></pre>
								<!--
				essentially:
				start with something basic
				then add in a thing to read from file
				then let's make it read from db
				now we have something a bit more complicated
				maybe read from db write to file
				with parameters

				bring it back down to chainable functions? and io.Reader / io.Writer

				sometimes all you need is a good ol' interface
			-->

		</div>
	</body>
</html>
